\documentclass[runningheads,11pt]{article}
\usepackage{fullpage}
\newif\ifanonymous
\anonymousfalse

\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{authblk}
\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{todonotes}

\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orrù}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{pifont}


\input{macros}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}

\newcommand{\serialize}{\texttt{Serialize}}
\newcommand{\deserialize}{\texttt{Deserialize}}
\newcommand{\frombytes}{\texttt{FromBytes}}
\newcommand{\statementnode}{\texttt{Statement}}
\newcommand{\statementleaf}{\texttt{StatementLeaf}}
\newcommand{\unsure}[1]{\textcolor{red}{#1}}
\newcommand{\simresponse}{\textsf{SimResp}}
\newcommand{\simcommitment}{\textsf{SimCom}}

\title{Proposal: $\Sigma$-protocols}
%

\author{Michele Orru \thanks{michele.orru@berkeley.edu} \and Stephan Krenn
\thanks{stephan.krenn@ait.ac.at}
}
\begin{document}
%
\maketitle              % typeset the header of the contribution
%
{\hypersetup{hidelinks} \tableofcontents}

\section{Introduction}

Zero-knowledge~\cite{GolMicRac89} proofs of knowledge~\cite{C:BelGol92} allow a prover to convince a verifier that he knows a secret piece of information, without revealing anything else that what is already revealed by the claim itself.
Many practically relevant proof goals can be realized using so-called $\Sigma$-protocols, or their non-interactive counterparts, which can be proven secure in the random oracle model without the need for a common reference string.
Introduced by Schnorr~\cite{JC:Schnorr91} over 30 years ago, they are now widely used  in practice because of their simplicity, maturity, and versatility.

$\Sigma$-protocols played an essential component in the building of a number of cryptographic
constructions,
such as anonymous credentials~\cite{CCS:ChaMeiZav14}, password-authenticated key exchange~\cite{jpake}, signatures~\cite{C:Schnorr89},
ring signatures~\cite{borromeansig}, blind signatures~\cite{CCS:PoiSte97}, multi signatures~\cite{CCS:NRSW20}, threshold signatures~\cite{EPRINT:KomGol20} and more.
\subsection{Notation}
\label{sec:notation}

For the purpose of this document, the following notation will be used:

\begin{tabular}{r@{\hspace{1em}}p{13cm}}
    $\secpar$ & main security parameter\\
    $a, x, w, \dots$ & elements $\!\!\!\mod p$ \\
    $\GG = \langle G \rangle$ & cyclic group of prime order $p$ generated by $G$\\
		$\CS$ & challenge set corresponding to $\{0,1\}^{256}$\\
    $G, H, Y, \dots$ & group elements in $\GG$ \\
    $\prover,\verifier,\dots$ & potentially randomized algorithms\\
    $x \defeq 1$ & assignment of the value 1 to $x$\\
    $x\sample\someset$ & assignment of a uniformly random element in $\someset$ to $x$\\
    $x\gets\alg(in)$ & assignment of the output of a randomized algorithm $\alg$ on input $in$ to $x$\\
    $\relation$ & binary relation\\
    $\lang(\relation)$ & language induced by a binary relation $\relation$\\
    % i.e., $\lang(\relation)=\{y\in\{0,1\}^*:\exists w$ such that $(y,w)\in\relation\}$.\\
    $|y|$ & bitlength of a string\\
    $\NN,\ZZ$ & non-negative natural numbers and integers, respectively
\end{tabular}
\section{Concepts}

\subsection{Terminology}

Zero knowledge means that the protocol does not leak any information about the prover's messages beyond what the attacker may infer form the proof itself or from other sources~\cite[1.6.4]{zkproof-reference}.

Soundness means that it is not possible to make the verifier accept for statements for which no valid witness exists~\cite[1.6.2]{zkproof-reference}.
If soundness relies on computational assumption, then we call the proof an \emph{argument}.
If a proof is extractable, that is, the the witness does not only exist but can be efficiently extracted, then the protocol a proof of knowledge~\cite{STOC:GolMicRac85,STOC:FeiFiaSha87,C:BelGol92} and is said to satisfy \emph{knowledge soundness}~\cite{damgard04}.
If the proof of knowledge is non-malleable, that is, if it is still secure against man-in-the middle attacks, then we call the proof \emph{simulation-extractable}.

All protocols defined here are simulation-extractable. A simulation-extractable proof is a proof of knowledge. A proof of knowledge is an argument.


\section{Generic $\Sigma$-Protocols}
In the following, we describe the class of $\Sigma$-protocols.
Such protocols can be used to prove that, for some binary relation $\relation$ and a public value $Y$, a witness $w$ such that $(Y,w)\in\relation$ is known.

In the following, we formally describe the class of $\Sigma$-protocols, which covers all protocols considered in the remainder of this document.
 For an in-depth discussion of the underlying theory we refer to Cramer~\cite{cramer97}.

 \subsection{Capabilities}
 $\Sigma$-protocols are composable: it is possible to prove conjunction and disjunctions of statements in zero-knowledge. Basic statements include proofs of knowledge of a secret key, openings of commitments, and more in general of representations.
Statements in $\Sigma$-protocols take the form of a labeled binary tree:
$\statementnode$ is either:
\begin{itemize}
  \item a label \textsf{AND}, or \textsf{OR}, and two children \textsf{left} and \textsf{right} of type $\statementnode$
  \item a $\statementleaf$ instance. Objects of this type depend on the specific algebraic setting used, and will be treated in \cref{sec:sigma-dlog}.
\end{itemize}

A $\Sigma$-protocol consists of three algorithms $(\prover_1,\prover_2,\verifier)$, where:
      The protocol is of the following form (cf. also~\cref{fig:generic}):
      \begin{itemize}
        \item
          In the first step, the prover computes a commitment $\commitment$ and some internal state, depending on the witness known to the prover and the statement to be proven.
					That is, the prover sets:
					$$(\commitment,\st) \gets \prover_1(\witness,\statement)\,$$
					and sends $\commitment$ to the verifier, while keeping $\st$ secret.
        \item
          The verifier draws a random challenge $\challenge\sample\CS$ and returns it to the prover.
        \item
          The prover next computes a response $\response$, depending on the witness, the statement, the challenge received from the verifier, and the internal state generated by $\prover_1$.
					That is, the prover computes
					$$\response\gets\prover_2(\witness,\statement,\challenge,\st)\,$$
					and sends $\response$ to the verifier.
        \item
          Depending on the statement, the prover's commitment, the random challenge, and the response, the verifier accepts or rejects the proof by computing:
					$$\accept/\reject \gets \verifier(\statement, \commitment,\challenge,\response)\,.$$
      \end{itemize}
%      The protocol transcript $(\commitment,\challenge,\response)$ is called \emph{accepting} if the verifier accepts the protocol run.

Besides these algorithms, also a so-called simulator is defined for $\Sigma$-protocols, which is needed when composing protocols to realize complex statements such as, e.g., knowledge of one out of a set of witnesses.
The simulator consists of the following two procedures:
\begin{itemize}
  \item
	  $\simresponse(\statement)$
	\item
	  $\simcommitment(\statement,\challenge,\response)$
\end{itemize}

\minote{We need also a $\simresponse$ procedure?}
  An additional procedure, called the simulator $\simulator$ is defined for the basic protocol instances and will be needed when composing protocols \cref{sec:sigma-dlog}.
 The flow of a $\Sigma$-protocol is also depicted in~\cref{fig:generic}.

    \begin{protocol}{Generic flow of a $\Sigma$-protocol.\\[-2.25em]}{fig:generic}{t}
      \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
        $\prover(\witness,\statement,\relation)$ & & $\verifier(\statement,\relation)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $(\commitment,\st) \gets \prover_1(\witness,\statement)$\\
        & $\sendr{\commitment}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $\challenge \sample \CS$ \\
        & $\sendl{\challenge}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets \prover_2(\witness,\statement,\commitment,\challenge,\st)$\\
        & $\sendr{\response}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & $\accept/\reject \gets \verifier(\statement,\commitment,\challenge,\response)$ \\
      \end{tabular}
    \end{protocol}

\begin{remark}
  The interactive versions of the $\Sigma$-protocols presented in this document are not fit for practical applications, due to subtle yet impactful details in their security guarantees.
%git For those applications where latency is not a problem, we direct the reader towards~\cref{XXX} for general techniques.
 For practical applications, their non-interactive versions---as described in \cref{sec:fs}---shall be used.
\end{remark}


\subsubsection{Serializing the statement}
  There are many different options for serialization that could be considered:
  \begin{itemize}
  \item Concise Binary Object Representation (CBOR) \href{https://datatracker.ietf.org/doc/html/rfc7049}{RFC7049}
    \item The zk proof Reference document provides a serialization document for r1cs~\cite[3.4.2]{zkproof-reference}, but there is nothing in it.
    \item Strobe [\href{https://strobe.sourceforge.io/specs/}{Strobe Specification}], which limits us to sponge functions
\end{itemize}
The tree is encoded in breadth-first.



\subsection{The Fiat-Shamir Transform}\label{sec:fs}
% \marynote{Considering you are stressing the importance of hashing the instance, I would send the instance in the first message of the interactive versions as well.}
All protocols described in this standard require three messages being exchanged between the prover and the verifier.
In practice, public-coin protocols such as $\sigma$ protocols can be converted into non-interactive ones through the
Fiat and Shamir heuristic~\cite{C:FiaSha86} and subsequent work, e.g., by Bernhard et al.~\cite{AC:BerPerWar12}

The underlying idea is to replace the verifier with a cryptographically secure hash function, hashing the context from the protocol and the previous message sent by the prover.

\begin{remark}
The interactive version of $\Sigma$-protocols presented in this paper is unfit for practical applications.
\end{remark}

\subsubsection{Hash Registry}

We support all of the following hash functions that takes as input a sequence of bytes of arbitrary length and output 32 bytes of entropy.

\begin{center}
  \begin{tabular}{lll}
  Hash & Security Level & Source \\
  \hline
  Blake2 \\
  Keccak & \\
  \unsure{Poseidon} &\\
  \end{tabular}
\end{center}

\minote{Randomness for the commitment: we can choose to rely on the operating system's entropy. For fault attacks, it does not seem ideal either to have a prf sqeezing all the entropy.}
\subsubsection{Randomness for the challenge}
\label{sec:fs-challenge}

% Truncating the output of the hash to $\ceil{\log_2 p} + \kappa$ bits (where $\kappa$ is the targeted statistical
%  security level), and then reducing mod $p$.
%  This approach leads to a random value statistically close ($2^{-\kappa}$) to a value sampled uniformly at random in $\ZZ_p$.

Multiple approaches have been used in the past~\cite{EPRINT:Hamburg17, hash-to-curve}.
The challenge is the hash of:
\begin{itemize}
  \item $\ctx$, a 32-byte string identifying the message, containing the
  hash of the following application-specific information:
  \begin{itemize}
    \item $\domsepctx$, a string determining uniquely the name of the target application (and the proof type);
    \item \textsf{id},
      local context information (e.g., session identifiers of higher level protocols) to avoid replay-attacks, or shared randomness or a timestamp to guarantee freshness of the proof.
  \end{itemize}
  \item $\tau$, a (possibly set to zero) message attached to the proof of 32 bytes.
  \item $\serialize(T)$, the serialization of the statement.
\end{itemize}

We note that the chosen hash functions allow for preprocessing: it is possible to store the partial state and process the commitment.



\subsubsection{Serializing the proof}

\minote{The prover must also work on a tree as input, and invoke the prove at associated to the root of the statement.}
There are two possible provers, short and batchable.
The short form has shorter proofs if the protocol contains at least an AND statement.
\minote{quantify the gain}

\minote{what if the statement / witness is not valid? should we run verification after proving?}
\begin{description}
\item[Batchable Form]
The prover's algorithm $\batchprover(\vec \witness, \vec \statement,\ctx, \stag)$ works as follows:
\begin{itemize}
\item
  Compute $(\vec \commitment,\st)\gets\prover_1(\vec \witness, \vec \statement)$.
\item
  Compute the challenge according to \cref{sec:fs-challenge}
\item
  Define $\vec \response\gets\prover_2(\vec \witness, \vec \statement,\challenge,\st)$.
  \item Optionally, check $\verifier(\vec \commitment, \challenge, \vec \response)$
	\stnote{add statement as input}
\item
  Output $\serialize(\commitment) \concat \serialize(\vec \response)$
\end{itemize}

\item[Short Form]
The prover's algorithm $\shortprover(\vec \witness, \vec \statement,\ctx, \stag)$ works as follows:
\begin{itemize}
  \item
    Compute $(\vec \commitment,\st)\gets\prover_1(\vec \witness, \vec \statement)$.
  \item
    Compute the challenge according to \cref{sec:fs-challenge}.
  \item
    Define $\vec \response\gets\prover_2(\vec \witness,\vec \statement, \challenge,\st)$.
    \item Optionally, check $\verifier(\vec \commitment, \challenge, \vec \response)$
  \item
  Our $\serialize(c) \concat \serialize(\vec s)$.
\end{itemize}
\end{description}

\subsection{Verification}
\minote{Add de-serialization sub-procedures that may fail}
\minote{Check the inputs to the sub-procedures, like the simulator is not having enough information for recomputing the challenge}

If input parsing fails, an exception should be raised.
If verification fails, an exception should be raised.
Otherwise, the verifier outputs $\pctrue$. Optionally, the implementation can choose to return the parsed statement.



\begin{description}
  \item[Batchable Form]
      The verifier's algorithm $\batchverifier(\vec \statement, \ctx, \stag, (\vec \commitment,\vec s))$ works as follows:
      \begin{itemize}
        \item
          Recompute the challenge as $\challenge\gets\hash(\vec \statement, \vec \commitment, \ctx, \stag)$.
        \item
          Output whatever $\verifier(\vec \statement,\vec \commitment,\challenge,\vec \response)$ outputs.
      \end{itemize}
      \paragraph{Remark.}
The case of batched verification must include a point verification sub-routing that asserts the statement and commitments are in question. Failure to properly check that a commitment is in the group could lead to subgroup attacks~\cite{EC:VanWie96,C:LimLee97} or invalid curve attacks~\cite{C:BieMeyMul00,RSA:BBPV12}.
  \item[Short Form]
      The verifier's algorithm $\shortverifier(\vec \statement, \ctx, \stag, (\challenge, \vec \response))$ works as follows:
      \begin{itemize}
        \item Set $\vec \commitment \gets \simulator(\challenge, \vec \response)$
        \minote{this is not correct}
         Recompute the first message $\vec \commitment$ by running the appropriate steps of the simulator $\simulator$.

    More precisely, we stress that, on input a challenge $\challenge$, all simulators introduced so far first draw a response $\response$, and then compute the commitment $\commitment$ from $\challenge$ and $\response$.
       Instead of sampling $\response$, use the input value to recompute $\commitment$ according to the remaining steps of the simulator.
        Check that $\challenge=\hash(\vec \commitment, \vec \statement, \ctx, \tau)$ and reject if this is not the case.
        \item Check $c = c^*$ where $c^*$ is computed according to \cref{sec:fs-challenge}.
      \end{itemize}
\end{description}




\subsection{Composition of $\Sigma$-Protocols}
\label{sec:composition}
\label{sec:or-comp}
\label{sec:and-comp}
  In this section, we specify composition techniques of $\Sigma$-protocols.
  Specifically, we define mechanisms for proving knowledge of multiple independent witnesses (\emph{AND composition}), and for proving knowledge for one out of a set of witnesses (\emph{OR composition}).
  Without loss of generality, the techniques presented in the following focus on the composition of two protocols;
  proving knowledge of more than two witnesses, or for out of a larger set of witnesses.
  For the rest of this section, we let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

\subsubsection{AND Composition}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of multiple independent witnesses, e.g., knowledge of multiple secret keys, or openings to multiple commitments.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
\[
  \relation^\land = \set{
    ((\statement^0,\statement^1),(\witness^0,\witness^1) : (\statement^0,\witness^0)\in \relation^0 ~\land~ (\statement^1,\witness^1)\in\relation^1}\,.
\]
  Intuitively, the algorithm simply runs the instances of the different protocols to be composed in parallel, using the same challenge $\challenge$ for all instances.
	The verifier will then accept the protocol run, if and only if all instances of the partial protocols output $\accept$.

\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(\vec \witness, \vec\statement)$ consists of the following steps:
    \begin{enumerate}
      \item
        Parse $(\witness^0,\witness^1)\defeq \vec \witness$ and $(\statement^0,\statement^1)\defeq \vec \statement$.
      \item
        Compute $(\commitment^0,\st^0)\gets\prover_1^0(\witness^0, \statement^0)$ and $(\commitment^1,\st^1)\gets\prover_1^1(\witness^1, \statement^1)$.
      \item
	Output $(\vec \commitment,\st) \defeq ((\commitment^0,  \commitment^1),(\st^0,\st^1))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(\vec \witness,\vec \statement,\challenge,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        Check that $\challenge\in\CS$ and aborts if this is not the case.
      \item
	Parse $(\st^0,\st^1)\defeq \st$
      \item
        Compute $s^0\gets\prover_2^0(\witness^0,\statement^0,\challenge,\st^0)$ and $s^1\gets\prover_2^1(\witness^1,\statement^1,\challenge,\st^1)$.
      \item
        Output $\vec \response\defeq(s^0,s^1)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(\vec \statement, \vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item
        Parse $(s^0,s^1)\defeq \vec \response$.
      \item
	Output $\verifier^0(\statement^0, \commitment^0,\challenge, \response^0)\land\verifier^1(\statement^1, \commitment^1,\challenge, \response^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(\vec Y,c)$ works as follows:
    \begin{enumerate}
      \item
        Parse $(\statement^0,\statement^1)\defeq \vec Y$.
      \item
        Choose $\challenge\sample\CS$.
      \item
        Compute $(\commitment^0,\challenge,s^0)\gets\simulator^0(\statement^0,c)$ and $(\commitment^1,\challenge,s^1)\gets\simulator^1(\statement^1,c)$.
      \item
        Finally, output $(\vec \commitment,\challenge, \vec \response)\defeq((\commitment^0, \commitment^1),\challenge,(s^0,s^1))$.
    \end{enumerate}
\end{enumerate}


\subsubsection{OR Composition}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of one out of a set of witnesses, e.g., one of a set of secret keys in the case of ring signatures.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
\[
  \relation^\lor = \set{
    ((\statement^0,\statement^1),(\witness^0,\witness^1) :
    (\statement^0,\witness^0)\in \relation^0 ~\lor~ (\statement^1,\witness^1)\in\relation^1}\,.
\]

  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $\witness^{1-j}$ is assumed to be unknown to the prover.

	On a high level, the protocol works as follows.
	Using the simulator, the prover first simulates a transcript for the unknown witness (keeping the challenge and response of this transcript temporarily secret), and generates an honest commitment for the known witness.
	Having received the challenge, the prover then computes challenge for the known witness, depending on the received challenge and the one from the simulated transcript.
	Having computed the response, the prover transfers the responses of both transcripts, as well as the partial challenges to the verifier, who accepts if and only if both instances of the partial protocols output $\accept$ and the partial challenges correctly add up to the random challenge.

	More specifically, the protocol flow is described in the following.
\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(\vec \witness, \vec \statement)$ consists of the following steps:
    \begin{enumerate}
      \item
        Parse $(\witness^0,\witness^1)\defeq \vec \witness$ and $(\statement^0,\statement^1)\defeq \vec \statement$, where $\witness^{1-j}=\bot$.
      \item
        Compute $(\commitment^j,\st^j)\gets\prover_1^j(\statement^j,\witness^j)$.
      \item
        Choose $\challenge^{1-j}\sample\CS$ and set $(\commitment^{1-j},\challenge^{1-j},s^{1-j})\gets\simulator^{1-j}(\statement^{1-j},\challenge^{1-j})$.
      \item
	Output $(\vec \commitment,\st) \defeq ((\commitment^0,\commitment^1),(\st^j,\challenge^{1-j},\response^{1-j}))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(\vec \witness, \vec \statement,\challenge,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        Check that $\challenge\in\CS$ and aborts if this is not the case.
      \item Parse $(\st^j,\challenge^{1-j},\response^{1-j})\defeq\st$.
      \item
        Compute $\challenge^j\defeq \challenge\oplus \challenge^{1-j}$, and sets $\response^j\gets\prover_2^j(\witness^j,\statement^j,\challenge^j,\st^j)$.
      \item
        Compute $s^0\gets\prover_2^0(\witness^0,\statement^0,\challenge,\st^0)$ and $s^1\gets\prover_2^1(\witness^1,\statement^1,\challenge,\st^1)$.
      \item
        Output $\vec \response\defeq(\response^0,\response^1, c^0)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(\vec \statement, \vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item
        Parse $(\response^0, \response^1, \challenge^0)\defeq \vec \response$.
      \item
        Set $\challenge^1\defeq \challenge \oplus \challenge^0$.
      \item
	    Output $\verifier^0(\statement^0, \commitment^0,c^0,s^0)\land\verifier^1(\statement^1, \commitment^1,c^1,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(\vec \statement,\challenge)$ works as follows:
    \begin{enumerate}
      \item
        Parse $(\statement^0,\statement^1)\defeq \vec \statement$.
      \item
        Choose a random $\challenge^0$ in $\CS$ and compute $\challenge^1\defeq \challenge \oplus \challenge^0$.
      \item
        Compute $(\commitment^0,\challenge^0, \response^0)\gets\simulator^0(\commitment^0,\challenge^0)$ and $(\commitment^1,\challenge^1,\response^1)\gets\simulator^1(\statement^1,\challenge^1)$.
      \item
        Output $(\vec \commitment,\challenge,\vec s)\defeq ((\commitment^0,\commitment^1),\challenge,(\response^0,\response^1,\challenge^0))$.
    \end{enumerate}
\end{enumerate}

\section{$\Sigma$-protocols in prime order groups}
\label{sec:instantiation}

\minote{
The $\Sigma$-protocols of this section provide the following guarantees}


\subsection{Ciphersuite Registry}
 We advise for the use of prime-order elliptic curves of size either 256 or 512 bits, depending on the desired security of the upper layers in the protocol\footnote{For instance, proving a DH relation with one fixed group element such as a public key, might expose the protocol to cryptanalytic attacks such as Brown-Gallant~\cite{EPRINT:BroGal04} and Cheon’s attack~\cite{EC:Cheon06}, and some implementations might opt for larger curve sizes. We consider these attacks out of scope for this standardization effort, and believe this analysis should be deferred to the concrete security study of the larger protocol.}.

 \vspace{1em}
 \begin{center}
 \begin{tabular}{llcc}
  \hline
  Curve  & Security Level & Sources \\
  \hline
  \verb|p-521|     & 256& \cite{fips2} \\
  \verb|p-256|     & 128 & \cite{fips2}  \\
  \verb|secp256k1| & 128 & \cite{SECG} \\
  \verb|Ristretto| & 128 & \cite{cfrg-ristretto-decaf} \\
  \verb|BLS12-381| & 128 & \cite{bls12} \\
 \end{tabular}
\end{center}
We denote with $\GG$ the prime-order group of the elliptic curve, with $\ZZ_p$ the scalar field, and with $G$ the generator of $\GG$.
We assume that all above ciphersuites provide the following functions:

\begin{itemize}
  \item \texttt{FromRandomBytes}, taking as input 32 bytes and mapping them into an element of the scalar field;
  \item \texttt{Serialize}, taking as input a point in the elliptic curve and returning a fixed-length sequence of bits;
  \item \texttt{Deserialize}, taking a (fixed-length and curve-dependent) sequence of bits and returning an elliptic curve point. This procedure may output an error if the conversion fails.
\end{itemize}

\subsection{Basic $\Sigma$-Protocols in prime-order groups}
\stnote{Check that commitment/challenge/response are not all zero}
For an in-depth discussion of the underlying theory we refer to Cramer~\cite{cramer97}.
 \begin{definition}
  For two groups $\GG_1,\GG_2$, a function $\varphi:\GG_1\to\GG_2:x\mapsto\varphi(x)$ is a \emph{(group) homomorphism}, if and only if for all $a,b\in\GG_1$ it holds that $\varphi(a+b)=\varphi(a)+\varphi(b)$.
\end{definition}




\label{sec:sigma-dlog}
A basic $\Sigma$-protocol for the relation:
\[
  \relation=\set{((\statement_1,\dots,\statement_m),(w_1,\dots,w_n)) : (\statement_1,\dots,\statement_m)=\varphi(w_1,\dots,w_n)}
\]
\minote{what if some of the $w$'s are publicly known}
\stnote{let all $\witness$'s be secret for the time being}
 for a group homomorphism $\varphi:\ZZ_p^n\to\GG^m$ is given by the following algorithms:

\begin{enumerate}
  \item\label{item:basic:p1}
    The prover's first algorithm $\prover_1(\vec \witness,\vec \statement)$ consists of the following steps:
    \begin{enumerate}
      \item\label{item:basic:p1:randomness}
        Choose random elements $r_1,\dots,r_n\sample\ZZ_p$.
      \item
        Compute $(\commitment_1,\dots,\commitment_m)\gets\varphi(r_1,\dots,r_n)$.
      \item Set $\st\defeq (r_1,\dots,r_n)$ and $\vec \commitment\defeq(\commitment_1,\dots,\commitment_m)$.
      \item
        Output $(\vec \commitment,\st)$.
    \end{enumerate}
  \item\label{item:basic:p2}
    The prover's second algorithm $\prover_2(\vec \witness,\vec Y ,\challenge,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        Let $c \defeq \frombytes(\challenge)$.
      \item Parse $(r_1,\dots,r_n)\defeq \st$ and $(w_1,\dots,w_n)\defeq \vec \witness$.
      \item Compute the response $s_i\defeq r_i+cw_i$ for $i=1,\dots,n$.
    \end{enumerate}
  \item\label{item:basic:v}
    The verifier's algorithm $\verifier(\vec \statement,\vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item Parse $(\response_1, \dots, \response_n) \defeq \vec \response$, $(\commitment_1, \dots, \commitment_m) \defeq \vec \commitment$, and $(\statement_1, \dots, \statement_m) = \vec \statement$.
      \item\label{item:basic:v:checks}
        Check that $\response_i\in\ZZ_p$ for $i=1,\dots,n$ and $\commitment_j\in\GG$ for $j=1,\dots,m$, and outputs $0$ if this is not the case.
      \item Check whether $(\commitment_1 + c\statement_1,\dots,\commitment_m + c\statement_m) = \varphi(s_1,\dots,s_n)$, and outputs $\accept$ if this is the case; otherwise, $\verifier$ outputs $\reject$.
    \end{enumerate}
  \item\label{item:basic:sim}
    The required simulator $\simulator(\vec \statement,c, \vec s)$ for a basic $\Sigma$-protocol works as follows:
    \begin{enumerate}
      \item
        Parse $(\statement_1,\dots,\statement_m)\defeq \vec \statement$.
      \item\label{item:basic:sim:s}
        Parse $\response_1,\dots,\response_n\sample\ZZ_p$.
      \item
        Set $(\commitment_1,\dots,\commitment_m) \defeq \varphi(s_1,\dots,s_n) - c(\statement_1,\dots,\statement_m)$.
      \item
        Finally, output the simulated transcript by setting $(\vec \commitment,\challenge,\vec \response)\defeq((\commitment_1,\dots,\commitment_m),\challenge,(\response_1,\dots,\response_n))$.
    \end{enumerate}
\end{enumerate}

\subsection{Proving linear relations among witnesses}
\stnote{or rewrite the homomorphism?}
  While the above protocol allows one to efficiently prove knowledge of a pre-image under a homomorphism, many protocols found in the literature require one to prove relations among witnesses.
  Specifically, they require to prove relations like the following:
\begin{equation*}
\relation=\set{((\statement_1,\dots,\statement_m),(\witness_1,\dots,\witness_n)) :
\begin{array}{c} (\statement_1,\dots,\statement_m)=\varphi(\witness_1,\dots,\witness_n) \\
                  A\cdot(\witness_1,\dots,\witness_n)^\intercal = (b_1,\dots,b_k)^\intercal\end{array}}\,,
\end{equation*}
where the matrix $A\in\ZZ_p^{k\times n}$ and vector $(b_1,\dots,b_k)\in\ZZ_p^k$ specify the system of linear equations.

Proving such a relation can easily by achieved by modifying the above protocol as follows:
\begin{itemize}
  \item
    In \cref{item:basic:p1:randomness}, the prover draws the randomnesses such that they satisfy the system of equations, i.e., such that $A\cdot(r_1,\dots,r_n)=(b_1,\dots,b_k)$.
  \item
    In \cref{item:basic:v:checks}, the verifier additionally checks that $A\cdot(\response_1,\dots,\response_n)^\intercal=(\challenge+1)\cdot(b_1,\dots,b_k)^\intercal$ and outputs $\reject$ if this is not the case.
  \item
    In \cref{item:basic:sim:s}, the simulator draws the responses such that they satisfy the verification equations, i.e., such that $A\cdot(\response_1,\dots,\response_n)=(c+1)\cdot(b_1,\dots,b_k)^\intercal$.
\end{itemize}


\subsection{Serializing the morphism}

the morphism is described via a unique string that identifies it, the group elements used in the morphism must be added
\subsection{Batch Verification}

The batchable form can take advantage of the following fact.
Given the single verification equations of the form:
\[
   \commitment_i + c_i Y_i = \sum_j s_{i, j} G_j
\]
for $i=0, \dots,\ell-1$,
%(So, $T \in \GG^\ell$, $c \in \ZZ_p^\ell$ and $s \in \ZZ_p^{\ell \times m}$ and $\mat G \in \GG^{m \times \ell}$.)
the verifier can sample a random vector of coefficients $a \in \ZZ_p^\ell$ instead test that:
\[
  \left(\sum_{i=0}^{\ell-1} a_i \commitment_i\right) + \left(\sum_{i=0}^{\ell-1} a_i \cdot  c_i \statement_i \right) = \left(\sum_{i=0}^{\ell-1} a_i \cdot \response_i G_i\right).
\]
If the matrix $G_{i, j}$ of generators has identical rows, by linearity the right-hand side can be computed as a single scalar product.
If the statements $\statement_i$'s have identical rows, by linearity the second term in the equation can be computed as a single scalar product.
The random vector $\vec a$ can be \emph{deterministically} generated by fixing $a_0 \defeq 1$ and setting $(a_1, \dots, a_{\ell-1}) \defeq \prg(\vec Y, \vec T,  \challenge, \vec s)$~\cite{bip-schnorr}.



\subsection{Examples}
\paragraph{Example 1 (DLOG).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the discrete logarithm $w$ of a point $Y$ in base $G$ means proving knowledge of $w\in\ZZ_p$ such that $Y=wG$.
For a description of this proof goal in the general case of residue classes, we also refer to~\cite[1.4.1]{zkproof-reference}.

Using the above notation, we have $\varphi:\ZZ_p^2\to\GG:x\mapsto xG$.
The protocol flow is then as depicted in~\cref{fig:dlog}.
    \begin{protocol}{Proving knowledge of a discrete logarithm.\\[-2.25em]}{fig:dlog}{bpt}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover\left(\witness,\statement,G\right)$ & & $\verifier\left(\statement,G\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\sample\ZZ_p$ & &\\
        $ T \defeq rG$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \defeq r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $T + cY = sG$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s\sample\ZZ_p$, and sets $T\gets sG-cY$.
It then outputs the simulated transcript $(\commitment,\challenge,s)$.


\paragraph{Example 2 (DLEQ).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving equality of the known discrete logarithm $w$ of $\statement_1$ in base $G$ and $\statement_2$ in base $H$ means proving knowledge of $(w_1,w_2)\in\ZZ_p$ such that $\statement_1=w_1G$ and $\statement_2=w_2H$, and $w_1=w_2$.

Using the above notation, we have $\varphi:\ZZ_p\to\GG^2:(x_1,x_2)\mapsto (x_1G,x_2H)$.
The linear system of equations $A(w_1,w_2)=b$ is given by $w_1-w_2=0$.
The protocol flow is then as depicted in~\cref{fig:dleq}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms.\\[-2.25em]}{fig:dleq}{b}
      \begin{tabular}{@{}l@{\hspace{-4em}}c@{\hspace{-3em}}r@{}}
        $\prover\left( (w_1,w_2),(\statement_1,\statement_2),(G,H)\right)$ & & $\verifier\left((\statement_1,\statement_2),(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1,r_2\sample\ZZ_p$ such that $r_1-r_2=0$ & &\\
        $ \commitment_1 \defeq r_1G$ & & \\
        $ \commitment_2 \defeq r_2H$ & & \\
        & $\sendr{\commitment_1,\commitment_2}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $\commitment_1 + c\statement_1 = s_1G$ \\
        & & $\commitment_2 + c\statement_2 = s_2H$ \\
        & & and $s_1-s_2=0$.
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\sample\ZZ_p$ such that $s_1-s_2=0$, and sets $\commitment_1\gets s_1G-c\statement_1$ and $\commitment_2\gets s_2H - c\statement_2$.
It then outputs the simulated transcript $((\commitment_1,\commitment_2),\challenge,(s_1,s_2))$.

\paragraph{Example 3 (DLEQ; alternative).}
The same proof goal as in the previous example can also be achieved by considering a slightly different homomorphism, which directly encodes the linear relation, that is $\varphi:\ZZ_p\to\GG^2:x\mapsto (xG,xH)$.
The protocol flow is then as depicted in~\cref{fig:dleq_2}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms (alternative).\\[-2.25em]}{fig:dleq_2}{t}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover \left(\witness,(\statement_1,\statement_2),(G,H) \right)$ & & $\verifier \left((\statement_1,\statement_2),(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\sample\ZZ_p$ & &\\
        $ \commitment_1 \defeq rG$ & & \\
        $ \commitment_2 \defeq rH$ & & \\
        & $\sendr{\commitment_1,\commitment_2}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
      $s \defeq r + cw $& & \\
      & $\sendr{s}{100}$\\[2ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $\commitment_1 + c\statement_1 = sG$ \\
        & & and $\commitment_2 + c\statement_2 = sH$. \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s\sample\ZZ_p$, and sets $\commitment_1\gets sG-c\statement_1$ and $\commitment_2\gets sH - c\statement_2$.
It then outputs the simulated transcript $((\commitment_1,\commitment_2),\challenge,s)$.





\begin{remark}
  The two protocols illustrated prove the same statement, but achieve this via different approaches.
  The first protocol uses the more general framework of liner relations among witnesses introduced above.
  Alternatively, as shown in the second protocol, the linear relation can also be realized by  directly incorporating the linear relation into the proof goal, thereby achieving a slightly shorter proof size (as the prover's last message consists of one element of $\ZZ_p$ less).

  However, when proving inhomogeneous linear relations, incorporating the relation into the homomorphism also requires some additional computations in the target group, which in certain cases might compensate the advantage of a smaller proof size.
\end{remark}


\paragraph{Example 4 (REP).}
Let $\GG$ be a group over an elliptic curve of prime order $p$.
Proving knowledge of a valid opening of a Pedersen commitment means proving knowledge of $w_1,w_2\in\ZZ_p$ such that $Y=w_1G + w_2H$.

Using the above notation, we have $\varphi:\ZZ_p^2\to\GG:(x_1,x_2)\mapsto x_1G + x_2H$.
The protocol flow is then as depicted in~\cref{fig:rep}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:rep}{hbpt}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover \left( (w_1,w_2),Y,(G,H)\right)$ & & $\verifier \left(Y,(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1\sample\ZZ_p$ & &\\
        $ r_2\sample\ZZ_p$ & &\\
        $ T \defeq r_1G + r_2H$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $T + cY = s_1G + s_2H$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\sample\ZZ_p$, and sets $T\defeq s_1G + s_2H -cY$.
It then outputs the simulated transcript $(\commitment,\challenge,(s_1,s_2))$.

\paragraph{Example 5 (DH).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the exponents of a valid Diffie-Hellman triple means proving knowledge of $w_1,w_2\in\ZZ_p$ such that $\statement_1=w_1G$, $\statement_2=w_2G$, and $\statement_3=w_1 w_2 G$.
Yet, the mapping $\ZZ_p^2\to\GG^3:(x_1,x_2)\mapsto (x_1G,x_2G,x_1x_2G)$ is not a homomorphism, and consequently the basic protocol presented before cannot be deployed directly.
However, the required multiplicative relation can be proven by observing that the proof goal is equivalent to $\statement_1=w_1G$, $\statement_2=w_2G$, and $\statement_3=w_2\statement_1$, leading the homomorphism $\varphi:\ZZ_p^2\to\GG^3:(x_1,x_2)\mapsto(x_1G,x_2G,x_2\statement_1)$.

The protocol flow is then as depicted in~\cref{fig:dh}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:dh}{t}
      \begin{tabular}{@{}l@{\hspace{-3em}}c@{\hspace{-2em}}r@{}}
        $\prover\left( (w_1,w_2),(\statement_1,\statement_2,\statement_3),G)\right)$ & & $\verifier\left((\statement_1,\statement_2,\statement_3),G \right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1\sample\ZZ_p$ & &\\
        $ r_2\sample\ZZ_p$ & &\\
        $ \commitment_1 \defeq r_1G$ & & \\
        $ \commitment_2 \defeq r_2G$ & & \\
        $ \commitment_3 \defeq r_2\statement_1$ & & \\
        & $\sendr{\commitment_1,\commitment_2,\commitment_3}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $\commitment_1 + c\statement_1 = s_1G$ \\
        & & $\commitment_2 + c\statement_2 = s_2G$ \\
        & & and $\commitment_3 + c\statement_3 = s_2\statement_1$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\sample\ZZ_p$, and sets $\commitment_1\defeq s_1G -c\statement_1$, $\commitment_2\defeq s_2G-c\statement_2$, and $\commitment_3\defeq s_2\statement_1-c\statement_3$.
It then outputs the simulated transcript $((\commitment_1,\commitment_2,\commitment_3),\challenge,(s_1,s_2))$.

As shown in this example, and in contrast to linear relations, multiplicative relations among witnesses typically require a reformulation of the proof goal in order to be compatible with the generic protocol presented above.
We refer, e.g., to Krenn~\cite{krenn12} for generic techniques.

\minote{Add OR prooof for knowledge of one of multiple discrete logs}




\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev3,cryptobib/crypto,additional}
\end{document}